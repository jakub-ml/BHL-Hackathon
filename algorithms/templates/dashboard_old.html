{% load static %}
<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dashboard pogodowy z mapą</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    /* Layout */
    body { font-family: Arial, sans-serif; margin: 20px; }
    .main-container { display: flex; gap: 24px; align-items: flex-start; justify-content: center; width: 100%; }

    /* Left column: map */
    .map-col { flex: 1 1 60%; min-width: 300px; }
    #map { height: 600px; width: 100%; border: 2px solid #ccc; border-radius: 12px; }

    /* Right column: results */
    .results-col { flex: 0 1 36%; min-width: 260px; max-width: 480px; }
    .report { background:#f0fdf4; padding:20px; border-radius:10px; margin:0; border:1px solid #bbf7d0; }

    .cta-primary{ display:inline-block; padding:14px 26px; font-size:1.05em; background: linear-gradient(45deg,#28a745,#2ecc71); color:#fff; border-radius:12px; border:none; cursor:pointer; text-decoration:none; }

    /* Item styles inside report */
    ul.pred-list { list-style:none; padding:0; margin:12px 0 0 0; }
    ul.pred-list li { margin-bottom:10px; padding:8px; border-radius:6px; background:#fff; border:1px solid #e6f4ea; transition: box-shadow 0.15s ease, transform 0.15s ease; }
    ul.pred-list li.hovered { box-shadow: 0 6px 16px rgba(0,0,0,0.12); transform: translateY(-3px); background: #eafff1; }

    /* Responsive: stack on small screens */
    @media (max-width: 900px) {
      .main-container { flex-direction: column; align-items: stretch; }
      #map { height: 420px; }
      .results-col { max-width: none; }
    }
  </style>
</head>
<body>

  <div class="main-container">
    <!-- MAP COLUMN -->
    <div class="map-col">
      <div id="map"></div>
    </div>

    <!-- RESULTS COLUMN -->
    <div class="results-col">
      <div class="report">
        <h2 style="margin-top:0;">Analiza Zakończona!</h2>
        <p style="margin-bottom:8px;">Podsumowanie emisji (posortowane — najmniejsza najpierw):</p>

        <ul class="pred-list">
          {% if prediction %}
            {% for p in prediction %}
              <li class="pred-item" data-location-id="{{ p.weather_log.location.id }}">
                <strong>Miejsce:</strong> {{ p.weather_log.location.city_name }}<br/>
                <strong>Koszt przewidziany:</strong> {{ p.prediction|floatformat:2 }}
              </li>
            {% endfor %}
          {% else %}
            <li>Brak predykcji w bazie.</li>
          {% endif %}
        </ul>

        <div style="margin-top:16px; display:flex; gap:10px; flex-wrap:wrap;">
          <a class="cta-primary" href="/algorithms/weather/">Rozpocznij Nową Analizę</a>
          <button class="cta-primary" id="zoomAllBtn" type="button">Pokaż wszystkie markery</button>
        </div>

        <hr style="margin:16px 0; border:none; border-top:1px solid #e6f4ea;" />
        <p style="font-size:0.9em; margin:0;">Najedź na wiersz z wynikami aby podświetlić odpowiadający mu pin na mapie.</p>
      </div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    // Wstawiamy serializowane JSONy (przekazane z widoku)
    // UWAGA: spodziewamy się, że locations zawiera pole 'id' (Location.id)
    const locations = {{ locations_json|safe }};
    const predictions = {{ predictions_json|safe }};

    // Mapowanie predykcji po location_id (bezpieczne względem duplikatów nazw)
    const predictionByLocation = {};
    for (const p of predictions) {
      if ('location_id' in p) {
        if (!(p.location_id in predictionByLocation)) predictionByLocation[p.location_id] = p.prediction;
      } else if ('city' in p) {
        // fallback: jeśli widok nie wysłał location_id, użyj nazwy miasta
        predictionByLocation[p.city] = p.prediction;
      }
    }

    // Inicjalizacja mapy
    const defaultCenter = [52.2297, 21.0122];
    const defaultZoom = 6;
    const map = L.map('map').setView(defaultCenter, defaultZoom);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    // Dodawanie markerów i mapowanie po location.id
    const markersById = {}; // { id: marker }
    const markers = [];
    const bounds = [];

    locations.forEach(loc => {
      const id = loc.id ?? loc.pk ?? null;
      const lat = parseFloat(loc.latitude);
      const lon = parseFloat(loc.longitude);
      if (isNaN(lat) || isNaN(lon)) return;

      bounds.push([lat, lon]);

      const cityName = loc.city_name;
      let popupHtml = `<strong>${cityName}</strong>`;

      // Prefer location-id mapping
      if (id && predictionByLocation[id] !== undefined) {
        popupHtml += `<br/><em>Predykcja:</em> ${Number(predictionByLocation[id]).toFixed(2)}`;
      } else if (predictionByLocation[cityName] !== undefined) {
        popupHtml += `<br/><em>Predykcja:</em> ${Number(predictionByLocation[cityName]).toFixed(2)}`;
      } else {
        popupHtml += `<br/><em>Brak predykcji</em>`;
      }

      const marker = L.marker([lat, lon]).addTo(map).bindPopup(popupHtml);
      markers.push(marker);
      if (id) markersById[id] = marker;
    });

    // Dopasuj widok do wszystkich markerów, jeśli istnieją
    function fitToMarkers() {
      if (bounds.length === 0) return;
      if (bounds.length === 1) {
        map.setView(bounds[0], 10);
      } else {
        map.fitBounds(bounds, { padding: [40, 40] });
      }
    }

    // Automatyczne dopasowanie po załadowaniu
    fitToMarkers();

    // Helper: ustaw styl "podświetlenia" - tu zmienimy przezroczystość pozostałych
    function highlightMarkerById(id) {
      // jeśli nie ma markerów, nic nie rób
      if (markers.length === 0) return;

      // Przyciemnij wszystkie
      markers.forEach(m => m.setOpacity(0.35));

      // Jeśli mamy przypisany marker do id, ustaw pełną widoczność i otwórz popup
      const target = markersById[id];
      if (target) {
        target.setOpacity(1);
        target.openPopup();
        map.panTo(target.getLatLng(), { animate: true });
      } else {
        // fallback: jeśli nie ma markerówById (bo view nie przesłał id), spróbuj dopasować po city name
        // (lista będzie miała data-location-id z nazwą w tym przypadku)
        const maybeName = id; // if id contains name
        for (const m of markers) {
          const latlng = m.getLatLng();
          // Nie mamy bezpośredniego city na markerze — nie wykonujemy więcej fallbacków
        }
      }
    }

    function clearHighlight() {
      markers.forEach(m => m.setOpacity(1));
    }

    // Hooki na listę wyników: hover i focus
    const items = document.querySelectorAll('.pred-item');
    items.forEach(it => {
      const locId = it.getAttribute('data-location-id');

      it.addEventListener('mouseenter', () => {
        it.classList.add('hovered');
        // jeśli locId to liczba, konwertuj
        const parsedId = Number(locId);
        highlightMarkerById(isNaN(parsedId) ? locId : parsedId);
      });

      it.addEventListener('mouseleave', () => {
        it.classList.remove('hovered');
        clearHighlight();
      });

      // Accessibility: focus/blur jako odpowiednik hover
      it.setAttribute('tabindex', 0);
      it.addEventListener('focus', () => {
        it.classList.add('hovered');
        const parsedId = Number(locId);
        highlightMarkerById(isNaN(parsedId) ? locId : parsedId);
      });
      it.addEventListener('blur', () => {
        it.classList.remove('hovered');
        clearHighlight();
      });

      // Click centers map on that marker
      it.addEventListener('click', () => {
        const parsedId = Number(locId);
        const target = markersById[isNaN(parsedId) ? locId : parsedId];
        if (target) {
          map.setView(target.getLatLng(), 12, { animate: true });
          target.openPopup();
        }
      });
    });

    // Przycisk do obchodzenia się z markerami
    document.getElementById('zoomAllBtn').addEventListener('click', () => {
      fitToMarkers();
    });

  </script>
</body>
</html>